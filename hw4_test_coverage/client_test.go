package main

import (
	"encoding/json"
	"encoding/xml"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"sort"
	"strconv"
	"strings"
	"testing"
)

// Generated by https://www.onlinetool.io/xmltogo/
type Root struct {
	Users []struct {
		Id int `xml:"id"`
		//Guid          string `xml:"guid"`
		//IsActive      string `xml:"isActive"`
		//Balance       string `xml:"balance"`
		//Picture       string `xml:"picture"`
		Age int `xml:"age"`
		//EyeColor      string `xml:"eyeColor"`
		FirstName string `xml:"first_name"`
		LastName  string `xml:"last_name"`
		Gender    string `xml:"gender"`
		//Company       string `xml:"company"`
		//Email         string `xml:"email"`
		//Phone         string `xml:"phone"`
		//Address       string `xml:"address"`
		About string `xml:"about"`
		//Registered    string `xml:"registered"`
		//FavoriteFruit string `xml:"favoriteFruit"`
	} `xml:"row"`
}

const GoodToken = "GoodToken"
const BadToken = "BadToken"

type TestCase struct {
	InitValue     interface{}
	ExpectedValue interface{}
}

// код писать тут
func SearchServer(w http.ResponseWriter, r *http.Request) {
	if r.Header.Get("AccessToken") != GoodToken {
		http.Error(w, "Token is bad", http.StatusUnauthorized)
		return
	}

	// Get limit
	param := r.URL.Query().Get("limit")
	if param == "" {
		http.Error(w, "Parameter limit is empty or not found", http.StatusInternalServerError)
		return
	}
	limit, err := strconv.Atoi(param)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Get offset
	param = r.URL.Query().Get("offset")
	if param == "" {
		http.Error(w, "Parameter offset is empty or not found", http.StatusInternalServerError)
		return
	}
	offset, err := strconv.Atoi(param)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	if offset > limit {
		http.Error(w, "offset most be les then limit", http.StatusInternalServerError)
		return
	}

	// Get order_by
	param = r.URL.Query().Get("order_by")
	if param == "" {
		http.Error(w, "Parameter order_by is empty or not found", http.StatusInternalServerError)
		return
	}
	orderBy, err := strconv.Atoi(param)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Get query
	query := r.URL.Query().Get("query")
	if query == "" {
		http.Error(w, "Parameter query is empty or not found", http.StatusInternalServerError)
		return
	}

	// Get order_field
	orderField := r.URL.Query().Get("order_field")
	if orderField == "" {
		orderField = "Name"
	}

	data, err := ioutil.ReadFile("./dataset.xml")
	if err != nil {
		panic(err.Error())
	}
	dataset := Root{}
	err = xml.Unmarshal(data, &dataset)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	found := make([]User, 0, 100)
	for _, user := range dataset.Users {
		name := user.FirstName + " " + user.LastName
		if !(strings.Contains(name, query) || strings.Contains(user.About, query)) {
			continue
		}
		found = append(found, User{Id: user.Id, Name: name, Gender: user.Gender, Age: user.Age, About: user.About})
	}

	switch orderField {
	case "Id":
		switch orderBy {
		case OrderByDesc:
			sort.Slice(found, func(i, j int) bool {
				return found[i].Id < found[j].Id
			})
		case OrderByAsc:
			sort.Slice(found, func(i, j int) bool {
				return found[i].Id > found[j].Id
			})
		}
	case "Age":
		switch orderBy {
		case OrderByDesc:
			sort.Slice(found, func(i, j int) bool {
				return found[i].Age < found[j].Age
			})
		case OrderByAsc:
			sort.Slice(found, func(i, j int) bool {
				return found[i].Age > found[j].Age
			})
		}
	case "Name":
		switch orderBy {
		case OrderByDesc:
			sort.Slice(found, func(i, j int) bool {
				return found[i].Name < found[j].Name
			})
		case OrderByAsc:
			sort.Slice(found, func(i, j int) bool {
				return found[i].Name > found[j].Name
			})
		}
	default:
		{
			http.Error(w, "Parameter order_field is incorrect", http.StatusInternalServerError)
			return
		}
	}

	if offset+limit < len(found) {
		limit = len(found)
	} else {
		limit = offset + limit
	}

	resp, err := json.Marshal(found[offset:limit])
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(resp)
}

/*
func TestToken(t *testing.T) {
	cases := []TestCase{
		{GoodToken, false},
		{BadToken, true},
	}
	ts := httptest.NewServer(http.HandlerFunc(SearchServer))
	defer ts.Close()

	for caseNum, item := range cases{
		client := SearchClient{
			URL: ts.URL,
			AccessToken: item.InitValue.(string),
		}
		_, err := client.FindUsers(SearchRequest{Query: "on", OrderField: "Age", OrderBy: OrderByAsIs, Limit: 1, Offset: 0})
		if item.ExpectedValue.(bool) && err == nil {
			t.Errorf("TestCase %d fail with token '%v'", caseNum, item.InitValue)
		}else if !item.ExpectedValue.(bool) && err != nil {
			t.Errorf("TestCase %d fail with token '%v'. Error: %v", caseNum, item.InitValue, err.Error())
		}
	}
}
*/
func TestInternalServerError(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(SearchServer))
	defer ts.Close()
	client := SearchClient{
		URL:         ts.URL,
		AccessToken: GoodToken,
	}
	_, err := client.FindUsers(SearchRequest{OrderBy: 8})
	if err == nil {
		t.Errorf("Test InternalServerError fail")
	}
}

func TestUrlIsNil(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(SearchServer))
	defer ts.Close()
	client := SearchClient{
		AccessToken: GoodToken,
	}
	_, err := client.FindUsers(SearchRequest{Query: "on", OrderField: "Age", OrderBy: OrderByAsIs, Limit: 1, Offset: 0})
	if err == nil {
		t.Errorf("Test TestUrlIsNil fail")
	}
}

func TestLimit(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(SearchServer))
	defer ts.Close()
	client := SearchClient{
		URL:         ts.URL,
		AccessToken: GoodToken,
	}
	_, err := client.FindUsers(SearchRequest{Query: "on", OrderField: "Age", OrderBy: OrderByAsIs, Limit: -1, Offset: 0})
	if err == nil {
		t.Errorf("Limit less then 0 not processed")
	}
	res, err := client.FindUsers(SearchRequest{Query: "on", OrderField: "Age", OrderBy: OrderByAsIs, Limit: 25, Offset: 0})
	if err != nil {
		t.Errorf("Error returned: %v", err.Error())
	}
	if len(res.Users) != 25 {
		t.Errorf("Limit greater then 25 not processed: returned %v", len(res.Users))
	}
}
